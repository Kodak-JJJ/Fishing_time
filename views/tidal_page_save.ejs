<%
  rootPath = '../views';
  location_id = location.location_id;
  function getFormat(date){
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hour = String(date.getHours()).padStart(2, '0');
    const minute = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day}T${hour}:${minute}`;
  }

  const today = new Date();
  const formatted = getFormat(today); // today
  const formattedYesterday = getFormat(new Date(Date.now() - 24*60*60*1000));
  const todayMinus30 = new Date(Date.now() - 30*24*60*60*1000);
  const formattedM30 = getFormat(todayMinus30);  // today - 30
  const todayPlus30 = new Date(Date.now() + 30*24*60*60*1000);
  const formattedP30 = getFormat(todayPlus30); // today + 30
%>

<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="../css/locationPage.css" type="text/css">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= location.name %> - Fishing time</title>
</head>

<body>
  <%# this location can be rendered data %>
  <h2><a href="/home_page">Back to Home page</a></h2>
  <h1><%= location.name %></h1>

  <form id="queryForm">
    <label>Data type:</label>
    <select id="data_type" name="data_type" required>
      <option value="">--Choose--</option>
      <option value="wlp">Water level predictions</option>
      <option value="wlo">Water level observations</option>
    </select>

    <label>Date range:</label>

    <input type="datetime-local" id="start_date" name="start_date"
           required value="<%= formattedYesterday %>" min="<%= formattedM30 %>" max="<%= formatted %>">
    <input type="datetime-local" id="end_date" name="end_date"
           required value="<%= formatted %>" min="<%= formattedM30 %>" max="<%= formatted %>">

    <button type="submit">Load data</button>
  </form>

  <!-- chart area -->
  <div style="height:420px; margin-top:12px;">
    <canvas id="chart"></canvas>
  </div>

  <div>
    <table id="levels" style="width:100%; border-collapse: collapse;">
      <thead>
        <tr>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Time</th>
          <th style="text-align:right; border-bottom:1px solid #ddd; padding:6px;">Water level (m)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Optional: a place to print errors -->
  <pre id="out" style="max-height:200px;overflow:auto;background:#f6f6f6;padding:6px;"></pre>

  <!-- Chart.js + date adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

  <!-- embed loc json -->
  <script id="location-json" type="application/json">
    <%- JSON.stringify(location).replace(/</g, '\\u003c') %>
  </script>

  <script type="text/javascript">
    const dataTypeSelect = document.getElementById("data_type");
    const startDateInput = document.getElementById("start_date");
    const endDateInput   = document.getElementById("end_date");

    // Common min value
    const COM_MIN  = "<%= formattedM30 %>";
    // Observation range: last 30 days
    const OBS_MAX  = "<%= formatted %>";
    // Prediction range: last 30days → + 30 days
    const PRED_MAX = "<%= formattedP30 %>";

    function applyDateRange() {
      if (dataTypeSelect.value === "wlp") {
        // Predictions: allow future
        startDateInput.min = COM_MIN;
        startDateInput.max = PRED_MAX;
        endDateInput.min   = COM_MIN;
        endDateInput.max   = PRED_MAX;

        if (startDateInput.value < COM_MIN) startDateInput.value = COM_MIN;
        if (endDateInput.value   < COM_MIN) endDateInput.value   = COM_MIN;
        if (startDateInput.value > PRED_MAX) startDateInput.value = PRED_MAX;
        if (endDateInput.value   > PRED_MAX) endDateInput.value   = PRED_MAX;
      } else {
        // Observations: no future
        startDateInput.min = COM_MIN;
        startDateInput.max = OBS_MAX;
        endDateInput.min   = COM_MIN;
        endDateInput.max   = OBS_MAX;

        if (startDateInput.value < COM_MIN) startDateInput.value = COM_MIN;
        if (endDateInput.value   < COM_MIN) endDateInput.value   = COM_MIN;
        if (startDateInput.value > OBS_MAX) startDateInput.value = OBS_MAX;
        if (endDateInput.value   > OBS_MAX) endDateInput.value   = OBS_MAX;
      }

      if (startDateInput.value > endDateInput.value) {
        endDateInput.value = startDateInput.value;
      }
    }

    dataTypeSelect.addEventListener("change", applyDateRange);
    applyDateRange(); // init

    const loc = JSON.parse(document.getElementById('location-json').textContent);

    let chart; // keep reference to destroy when re-plotting

    // Map your API JSON to Chart.js points.
    function toPoints(json) {
      if (!Array.isArray(json)) return [];
      if (json.length && !Array.isArray(json[0]) && "eventDate" in json[0] && "value" in json[0]) {
        return json
          .slice()
          .map(r => ({ x: new Date(r.eventDate), y: Number(r.value) }));
      }
      return [];
    }

    function draw(points, title = "Series") {
      const ctx = document.getElementById("chart");
      if (chart) chart.destroy();

      chart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [{
            label: title,
            data: points,           // [{x: Date, y: Number}, ...]
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.2
          }]
        },
        options: {
          scales: {
            x: { type: "time", time: { tooltipFormat: "PPpp" } },
            y: { beginAtZero: true }
          },
          plugins: {
            decimation: { enabled: true, algorithm: "lttb", samples: 1000 },
            tooltip: { mode: "index", intersect: false }
          }
        }
      });
    }

    function renderTableFromPoints(points, {
      zone = "America/Vancouver",
      decimals = 2,
      target = "#levels tbody",
    } = {}) {
      const tbody = document.querySelector(target);
      if (!tbody) return;

      const rowsHtml = points.map(p => {
        const d = p.x instanceof Date ? p.x : new Date(p.x);
        const timeStr = d.toLocaleString("en-CA", {
          year: "numeric", month: "2-digit", day: "2-digit",
          hour: "2-digit", minute: "2-digit", second: "2-digit",
          timeZone: zone
        });
        const val = Number(p.y);
        return `<tr>
          <td style="padding:6px; border-bottom:1px solid #f0f0f0;">${timeStr}</td>
          <td style="padding:6px; text-align:right; border-bottom:1px solid #f0f0f0;">
            ${Number.isFinite(val) ? val.toFixed(decimals) : ""}
          </td>
        </tr>`;
      }).join("");

      tbody.innerHTML = rowsHtml;

      const table = tbody.parentElement;
      if (!table) return;

      // Wrap the table in a scrollable div (only once)
      let wrapper = table.parentElement;
      if (!wrapper || !wrapper.classList.contains("table-scroll-wrapper")) {
        wrapper = document.createElement("div");
        wrapper.classList.add("table-scroll-wrapper");
        table.parentNode.insertBefore(wrapper, table);
        wrapper.appendChild(table);
      }

      // Calculate height for ~10 rows
      const firstRow = tbody.querySelector("tr");
      if (firstRow) {
        const rowHeight = firstRow.getBoundingClientRect().height || 24; // fallback
        const visibleRows = 10;
        wrapper.style.maxHeight = `${rowHeight * visibleRows}px`;
        wrapper.style.overflowY = "auto";
        wrapper.style.display = "block";
      }
    }

    document.getElementById("queryForm").addEventListener("submit", async (e) => {
      e.preventDefault();

      const fd = new FormData(e.target);
      const start_date = fd.get("start_date");
      const end_date   = fd.get("end_date");
      const dataType   = fd.get("data_type");

      const fromDate = new Date(start_date);
      const toDate   = new Date(end_date);

      const fromStr = fromDate.toISOString().slice(0, 19) + "Z";
      const toStr   = toDate.toISOString().slice(0, 19) + "Z";

      const params = new URLSearchParams();
      params.append("time-series-code", dataType);
      params.append("from", fromStr);
      params.append("to", toStr);
      params.append("resolution", "FIFTEEN_MINUTES");

      const apiPrefix = '/tidal_location';
      const url = `${apiPrefix}/stations/${encodeURIComponent(loc.station_id)}/data?${params.toString()}`;
      console.log(url);

      try {
        const res = await fetch(url);
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`Request failed: ${res.status} ${text}`);
        }
        const json = await res.json();

        const points = toPoints(json);
        renderTableFromPoints(points);

        if (!points.length) {
          alert("No plottable points (eventDate/value) found in the response.");
          return;
        }
        draw(points, `Station ${loc.name} — ${start_date} - ${end_date}`);
      } catch (err) {
        document.getElementById("out").textContent = String(err);
      }
    });
  </script>
</body>
</html>
